<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="../../node_modules/mocha/mocha.css">
<script src="../../node_modules/mocha/mocha.js"></script>
<script src="../../node_modules/chai/chai.js"></script>
<script src="../../bin/traceur.js"></script>
<script src="../test-utils.js"></script>
<script src="../test-list.js"></script>
<script>


mocha.setup({ui: 'tdd'});

</script>
<script>

var assert = chai.assert;

// TODO(arv): Remove these aliases.
var assertEquals = assert.equal;
var assertFalse = assert.isFalse;
var assertNotEquals = assert.notEqual;
var assertNotNull = assert.isNotNull;
var assertNotThrows = assert.doesNotThrow;
var assertTrue = assert.isTrue;
var assertUndefined = assert.isUndefined;

function fail(m) {
  throw new chai.AssertionError({message: m});
}

function assertThrows(fn) {
  try {
    fn();
  } catch (ex) {
    return ex;
  }
  fail('Expected function to throw');
}

</script>
<script src="util/url.js"></script>
<script src="util/ErrorReporter.js"></script>
<script src="syntax/LineNumbers.js"></script>
<script src="syntax/Token.js"></script>
<script src="syntax/parser.js"></script>
<script src="codegeneration/writer.js"></script>
<div id="mocha"></div>
<script>

(function() {
  'use strict';

  function runCode(code, name) {
    try {
      ('global', eval)(code);
    } catch (e) {
      fail('Error running compiled output for : ' + name + '\n' + e + '\n' +
           code);
    }
  }

  function featureTest(name, url) {
    var urlOptions = {};

    var loadError = false;
    var loaded = false;

    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onerror = function() {
      loadError = true;
    };

    xhr.onloadend = function() {
      loaded = true;
    };
    xhr.send();

    test(name, function(done) {
      if (loaded) {
        doTest(done);
      } else {
        xhr.onloadend = function() {
          doTest(done);
        };
      }
    });

    function doTest(done) {
      if (loadError) {
        fail('Load error');
        done();
        return;
      }

      var source = xhr.responseText;

      traceur.options.debug = true;
      traceur.options.freeVariableChecker = true;
      traceur.options.validate = true;

      var options = parseProlog(source);
      var skip = options.skip;
      var shouldCompile = options.shouldCompile;
      var expectedErrors = options.expectedErrors;

      try {
        var reporter = new traceur.util.TestErrorReporter();
        var sourceFile = new traceur.syntax.SourceFile(name, source);
        var tree = traceur.codegeneration.Compiler.compileFile(reporter,
                                                               sourceFile,
                                                               url);
        var code = traceur.outputgeneration.TreeWriter.write(tree);

        if (!shouldCompile) {
          assert.isTrue(reporter.hadError(),
              'Expected error compiling ' + name + ', but got none.');

          var missingExpectations = expectedErrors.forEach(function(expected) {
            assert.isTrue(reporter.hasMatchingError(expected),
                          'Missing expected error: ' + expected);
          });

          skip = true;
        }

        var CloneTreeTransformer = traceur.codegeneration.CloneTreeTransformer;

        if (!skip) {
            if (reporter.hadError()) {
              fail('Error compiling ' + name + '.\n' +
                   reporter.errors.join('\n'));
              return;
            }
            if (urlOptions.testClone === 'true') {
              var clone = CloneTreeTransformer.cloneTree(tree);
              code = traceur.outputgeneration.TreeWriter.write(tree);
              var cloneCode = traceur.outputgeneration.TreeWriter.write(clone);
              assert.equal(code, cloneCode);
            } else {
              // Script compiled, so run it.
              runCode(code, name);
            }
        }
      } finally {
        traceur.options.reset();
      }

      done();
    }
  }

  // Bucket tests.
  var tree = {};
  testList.forEach(function(path) {
    var parts = path.split('/');
    var suiteName = parts.slice(0, -1).join(' ');
    var testName = parts[parts.length - 1];
    if (!tree[suiteName])
      tree[suiteName] = [];
    tree[suiteName].push({name: testName, path: path});
  });

  suite('Feature Tests', function() {
    for (var suiteName in tree) {
      suite(suiteName, function() {
        tree[suiteName].forEach(function(tuple) {
          featureTest(tuple.name, '../feature/' + tuple.path);
        });
      });
    }
  });

})();

</script>
<script>

mocha.run();

</script>
